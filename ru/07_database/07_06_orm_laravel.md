# ORM в Laravel

В Laravel используется Eloquent ORM, который предоставляет удобные инструменты для работы с базами данных [^2].

Eloquent позволяет работать с таблицами баз данных как с объектами, что упрощает процесс взаимодействия с данными.

При использовании Eloquent в Laravel, каждая таблица базы данных представляется в виде модели.

**Модель в Laravel** — это класс, который отображает таблицу базы данных и позволяет выполнять запросы к ней.

## Создание модели

Для создания модели в Laravel используется команда `php artisan make:model ModelName`.

Например, для создания модели `Post` выполните следующую команду:

```bash
php artisan make:model Post
```

Если вы хотите создать модель вместе с миграцией, используйте флаг `--migration`:

```bash
php artisan make:model Post --migration
```

Модели сохраняются в директории `app/Models`.

### Как Eloquent понимает какая таблица соответствует модели?

Eloquent использует соглашение об именовании для определения таблицы, которая соответствует модели.

По соглашению, в качестве имени таблицы будет использоваться имя класса в формате `snake_case`, во множественном числе, если явно не указано другое.

**Например**,

1. Модель `Post` будет соответствовать таблице `posts`.
2. Модель `UserProfile` будет соответствовать таблице `user_profiles`.

Если имя таблицы отличается от соглашения, вы можете явно указать имя таблицы в модели:

```php
class Post extends Model
{
    protected $table = 'my_posts';
}
```

## Первичный ключ

По умолчанию, Eloquent ожидает, что первичный ключ таблицы называется `id` и автоматически автоинкрементируется.

Если имя первичного ключа отличается или вы хотите сделать его не автоинкрементируемым, вы можете указать это в модели:

```php
class Post extends Model
{
   // Имя первичного ключа
   protected $primaryKey = 'post_id';

   // Первичный ключ не автоинкрементируется
   public $incrementing = false;
}
```

### UUID в качестве первичного ключа

> [!NOTE]
>  **UUID** (_Universally Unique Identifier_) — это 128-битное число, которое гарантированно уникально во всем мире [^1].

Если вы хотите использовать UUID в качестве первичного ключа используйте трейт `HasUuids`:

```php
class Post extends Model
{
    use HasUuids;

    // ...
}

// Например
$post->id; // 550e8400-e29b-41d4-a716-446655440000
```

## Получение данных

Для получения данных в Laravel больше нет необходимости использовать SQL-запросы напрямую. Вместо этого можно воспользоваться методами Eloquent.

### Получение всех записей

```php
$posts = Post::all();
// эквивалентно
$posts = DB::table('posts')->get();
```

### Создание запросов

Методы Eloquent позволяют создавать запросы, используя построитель запросов, который вы уже изучили.

Вы уже не используйте `DB`, а напрямую обращаетесь к модели.

```php
$posts = Post::where('status', 'published')
    ->orderBy('created_at', 'desc')
    ->get();
```

Эти методы делают процесс работы с базой данных более удобным и интуитивным.

### Извлечение отдельных записей

Для извлечения отдельной записи в Laravel можно использовать метод `find($id)`, где `$id` — это первичный ключ записи.

```php
// Получить модель по первичному ключу
// Если модель не найдена, возвращается null
$post = Post::find(1);
```

Для поиска записи по другому полю, например, по `slug`, можно использовать метод `first()`:

```php
// Получить модель по другому полю
$post = Post::where('slug', 'first-post')->first();
```

Аналогичный результат можно получить, используя метод `firstWhere`:

```php
// Использовать метод firstWhere
$post = Post::firstWhere('slug', 'first-post');
```

Если необходимо выполнить определённую логику в случае, если запись не найдена, можно воспользоваться методом `findOr()`, который принимает замыкание для обработки отсутствия записи:

```php
// Если запись не найдена, выполняется переданная функция
// В данном случае возвращается ответ 404
$post = Post::findOr(1, function () {
    return response('Post not found', 404);
});
```

Для более строгого подхода можно использовать метод `findOrFail($id)`, который выбросит исключение `ModelNotFoundException`, если запись не найдена:

```php
// Выбросить исключение, если запись не найдена
$post = Post::findOrFail(1);
```

Этот метод особенно полезен в тех случаях, когда необходимо немедленно обработать ошибку отсутствия данных, например, для автоматической отправки ответа с ошибкой 404.

### Использование аггрегатных функций

Для использования аггрегатных функций, таких как `count`, `sum`, `avg`, `min`, `max`, можно использовать методы Eloquent:

```php
// Получить количество записей
$postCount = Post::count();

// Получить количество опубликованных записей
$postCount = Post::where('status', 'published')->count();

// Получить сумму значений поля
$sum = Post::sum('views');

// Получить максимальное значение поля views
$maxSum = Post::where('status', 'published')->max('views');
```

## Вставка данных

Для вставки данных в базу данных в Laravel используется метод `save()`:

```php
$post = new Post();
$post->title = 'New Post';
$post->content = 'Content';
$post->save();
```

## Обновление данных

Для обновления уже существующей записи также можно использовать метод `save()`:

```php
$post = Post::find(1);
$post->title = 'Updated Post';
$post->save();
```

## Массовое присвоение

> [!NOTE] **Массовое присвоение (mass assignment)** — это процесс, при котором несколько атрибутов модели одновременно присваиваются и сохраняются в базе данных.

В примерах создания и обновления данных мы использовали метод `save()`, который работает с одной записью. Это неэффективно, если нужно обновить или создать сразу несколько записей. В Laravel для этого предусмотрены методы `create()` и `update()`.

### Массовое создание

Для массового создания записей используется метод `create()`, который принимает массив данных для создания новых записей.

Пример создания одной записи:

```php
Post::create([
   'title' => 'New Post',
   'content' => 'Content',
   'status' => 'draft'
]);
```

Пример создания нескольких записей:

```php
Post::create([
    ['title' => 'Post 1', 'content' => 'Content 1', 'status' => 'draft'],
    ['title' => 'Post 2', 'content' => 'Content 2', 'status' => 'draft'],
    ['title' => 'Post 3', 'content' => 'Content 3', 'status' => 'draft']
]);
```

Если данные приходят в запросе (например, из формы), их можно сохранить в базу данных одной командой:

```php
// Массовое создание записей из запроса
Post::create($request->all());
```

### Массовое обновление

Для массового обновления записей используется метод `update()`, который принимает массив данных для изменения существующих записей:

```php
// Обновить все записи, у которых статус "draft", на "published"
Post::where('status', 'draft')->update(['status' => 'published']);
```

## Поля `$fillable` и `$guarded`

Для массового присвоения данных в Laravel необходимо указать, какие поля могут быть заполнены. Это делается с помощью свойств `$fillable` или `$guarded` в модели. Важно отметить, что использовать оба свойства одновременно не имеет смысла, так как одно исключает другое.

### `$fillable`

Свойство `$fillable` определяет список полей, которые можно массово присваивать. Если вы хотите разрешить массовое присвоение только определённым полям, используйте `$fillable`.

Пример:

```php
class Post extends Model
{
    protected $fillable = ['title', 'content', 'status'];
}
```

В этом примере только поля `title`, `content` и `status` могут быть заполнены при массовом присвоении. Если вы попытаетесь передать другие поля, Laravel их проигнорирует.

Пример:

```php
Post::create([
    'title' => 'New Post',
    'content' => 'Content',
    'status' => 'draft',
    'is_published' => true // Это поле будет проигнорировано, так как его нет в $fillable
]);
```

### `$guarded`

С другой стороны, `$guarded` определяет поля, которые **нельзя** массово присваивать. Все поля, которые не указаны в `$guarded`, будут доступны для массового присвоения.

Пример:

```php
class Post extends Model
{
    protected $guarded = ['is_published']; // Защищаем поле от массового присвоения
}
```

В этом примере все поля модели, кроме `is_published`, можно массово присваивать. Если кто-то попытается передать значение для поля `is_published`, Laravel заблокирует это действие.

Пример:

```php
Post::create([
    'title' => 'New Post',
    'content' => 'Content',
    'status' => 'draft',
    'is_published' => true // Это поле будет заблокировано
]);
```

### Когда использовать `$fillable` и `$guarded`

Использовать одновременно `$fillable` и `$guarded` не имеет смысла, так как они противоречат друг другу. Если вы используете `$fillable`, Laravel будет работать только с указанными полями. Если используете `$guarded`, Laravel заблокирует присвоение полей, указанных в этом свойстве, и разрешит массовое присвоение всех остальных.

### Пример использования

```php
class Post extends Model
{
    // Можно массово присваивать только эти поля
    protected $fillable = ['title', 'content', 'status'];

    // Поле is_published нужно изменить вручную
}
```

Для полей, не указанных в `$fillable` или `$guarded`, Laravel автоматически проигнорирует их присвоение:

```php
Post::create([
    'title' => 'New Post',
    'content' => 'Content',
    'status' => 'draft',
    'views' => 1000 // Поле views будет проигнорировано, так как его нет в $fillable или $guarded
]);
```

Итак, важно определиться, какие именно поля могут быть массово присвоены. Используйте либо `$fillable` для указания разрешённых полей, либо `$guarded` для защиты только определённых полей.

## Удаление данных

Для удаления записи в Laravel используется метод `delete()`, но перед этим необходимо получить модель, которую вы хотите удалить.

```php
$post = Post::find(1);
$post->delete();

// или в одну строку
Post::find(1)->delete();

// можно добавить условие на существование записи
Post::findOrFail(1)->delete();
```

С помощью метода `destroy()` можно удалить запись по первичному ключу.

У данного метода есть недостаток, если модель не найдена, он выбросит исключение, поэтому нужно будет обрабатывать исключение.

```php
Post::destroy(1);

// или для удаления нескольких записей
Post::destroy([1, 2, 3]);
```

Можно удалять записи **по заданным условиям**.

```php
Post::where('status', 'draft')->delete();
```

## Заключение

## Вывод

Eloquent ORM в Laravel предоставляет мощный и удобный инструмент для работы с базами данных, позволяя работать с таблицами как с объектами, что значительно упрощает процесс взаимодействия с данными. Используя команды для создания моделей, автоматическое определение соответствия моделей таблицам и методы для работы с записями, разработчики могут создавать, обновлять и удалять данные, практически не задумываясь о написании SQL-запросов. 

Особенно полезными являются механизмы массового присвоения, которые ускоряют работу с большими объёмами данных, однако они требуют внимания к защите полей с помощью свойств `$fillable` и `$guarded`, чтобы обеспечить безопасность приложения. Также Eloquent предоставляет возможности для использования агрегатных функций и работы с первичными ключами, что делает его гибким инструментом для обработки данных. 

Таким образом, Eloquent ORM позволяет легко интегрировать работу с базой данных в логику приложения, обеспечивая при этом высокий уровень безопасности и производительности.

[^1]: The Benefits of Using UUIDs for Unique Identification, tiDB [online]. URL: https://www.pingcap.com/article/the-benefits-of-using-uuids-for-unique-identification/

[^2]: Eloquent: Getting Started. laravel.com [online]. URL: https://laravel.com/docs/eloquent
