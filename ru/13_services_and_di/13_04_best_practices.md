## Best Practices (Лучшие практики)

При проектировании приложения важно соблюдать лучшие практики, чтобы архитектура оставалась чистой, понятной и удобной для сопровождения.

В качестве отличного ресурса по теме Laravel и архитектуры сложных приложений рекомендуем книгу Аделя Файзрахманова [«Архитектура сложных веб-приложений. С примерами на Laravel»](https://github.com/adelf/acwa_book_ru).

Вот основные рекомендации по работе с сервисами и разделению ответственности.

### Когда использовать сервисы?

**Сервисы** — это классы, которые инкапсулируют бизнес-логику и делают её доступной для других частей приложения. Использование сервисов оправдано в следующих случаях:

1. **Сложная бизнес-логика**:
   Если логика выполнения задачи включает несколько шагов, её стоит вынести в отдельный сервис для упрощения кода.

2. **Повторное использование**:
   Если одна и та же логика требуется в разных частях приложения (например, в контроллерах или консольных командах), её нужно вынести в сервис.

3. **Лёгкость тестирования**:
   Сервисы проще тестировать отдельно от других компонентов, так как они не зависят от фреймворка (например, от HTTP-запросов).

4. **Явное отделение бизнес-логики**:
   Контроллеры должны оставаться максимально простыми, а основная логика приложения должна находиться в сервисах.

### Как не усложнять архитектуру?

При разработке важно помнить, что усложнённая архитектура приводит к трудностям в сопровождении и снижает производительность команды. Чтобы избежать этого:

1. **Не создавайте сервисы без необходимости**:
   Не выносите простую логику, которая используется в одном месте, в отдельный сервис.

2. **Соблюдайте принцип "одно действие — один сервис"**:
   Каждый сервис должен выполнять одну конкретную задачу. Не перегружайте его лишней логикой.

3. **Старайтесь не увлекаться абстракциями**:
   Избыточное количество интерфейсов и уровней абстракции может сделать код излишне сложным.

4. **Следуйте принципу YAGNI (You Aren't Gonna Need It)**:
   Не внедряйте функциональность, которая может не понадобиться в будущем.

### Разделение ответственности (Single Responsibility Principle)

Принцип единственной ответственности (SRP) гласит, что класс должен выполнять только одну задачу. Это облегчает тестирование, понимание и сопровождение кода.

#### Пример нарушения SRP:

```php
class AuthController extends Controller
{
    public function login(Request $request)
    {
        $user = User::where('email', $request->email)->first();

        if (!$user || !Hash::check($request->password, $user->password)) {
            return response()->json(['error' => 'Invalid credentials'], 401);
        }

        $token = $user->createToken('auth_token')->plainTextToken;

        return response()->json(['token' => $token]);
    }
}
```

В данном примере контроллер выполняет сразу несколько задач:

1. Проверяет пользователя.
2. Хеширует и проверяет пароль.
3. Создаёт токен.

Это делает код сложным для тестирования и нарушает принцип SRP.

### Пример: Разделение логики аутентификации в сервис

Логика аутентификации может быть вынесена в отдельный сервис:

```php
class AuthService
{
    public function authenticate(string $email, string $password): string
    {
        $user = User::where('email', $email)->first();

        if (!$user || !Hash::check($password, $user->password)) {
            throw new \Exception('Invalid credentials');
        }

        return $user->createToken('auth_token')->plainTextToken;
    }
}
```

Теперь контроллер становится намного проще:

```php
class AuthController extends Controller
{
    protected AuthService $authService;

    public function __construct(AuthService $authService)
    {
        $this->authService = $authService;
    }

    public function login(Request $request)
    {
        try {
            $token = $this->authService->authenticate($request->email, $request->password);
            return response()->json(['token' => $token]);
        } catch (\Exception $e) {
            return response()->json(['error' => $e->getMessage()], 401);
        }
    }
}
```

### Преимущества подхода

1. **Простота тестирования**:
   Теперь можно протестировать `AuthService` независимо от HTTP-запросов, обеспечив надёжность логики.

2. **Понятность кода**:
   Контроллер выполняет только одну задачу — обрабатывает запросы и передаёт их сервису.

3. **Повторное использование**:
   `AuthService` можно использовать в других частях приложения, например, в консольных командах или событиях.

4. **Лёгкость сопровождения**:
   Изменения в логике аутентификации потребуют изменения только сервиса, а не всего приложения.

### Резюме

1. Используйте сервисы для сложной, повторяемой или независимой логики.
2. Соблюдайте принцип SRP — разделяйте ответственность между классами.
3. Не усложняйте архитектуру избыточными абстракциями.
4. Организуйте код так, чтобы его было легко тестировать, сопровождать и расширять.
