# Использование сервисов

## Понятие сервисов в приложении

В разделе об архитектуре веб-приложений мы уже упоминали понятие _сервиса_. Тогда речь шла о сервисах как части общей архитектуры системы. В этой главе мы сосредоточимся на их роли в рамках одного приложения.

**Сервис** — это класс, выполняющий конкретную задачу. Основная цель сервисов — структурировать код, разделяя функционал приложения на независимые части. Такой подход упрощает понимание, тестирование и поддержку кода.

Для лучшего понимания можно привести аналогию из реальной жизни. Представьте ресторан:

- Повар готовит блюда.
- Официант обслуживает посетителей.
- Администратор управляет процессами.

Каждый выполняет свою задачу, и вместе они обеспечивают бесперебойную работу ресторана. Сервисы в приложении работают по такому же принципу: каждый отвечает за свою функцию, и все вместе они обеспечивают работу системы.

Примеры задач, которые могут выполнять сервисы:

- Работа с базой данных.
- Управление файлами.
- Обработка бизнес-логики.

Сервисы помогают распределить обязанности между различными частями приложения, делая его более гибким и легко поддерживаемым.

## Что такое бизнес-логика и предметная область?

Перед изучением сервисов важно понять два ключевых понятия: _бизнес-логика_ и _предметная область_.

**Бизнес-логика** — это правила и процессы, которые определяют, как приложение выполняет свои задачи в рамках специфической области.

**Предметная область** — это область знаний, для которой создаётся приложение. Например:

- Для интернет-магазина — продажа товаров.
- Для социальной сети — взаимодействие между пользователями.
- Для финансового приложения — управление финансами.

> [!NOTE]
> В больших проектах рекомендуется использовать подход, _ориентированный на предметную область ([Domain-Driven Design](https://www.techtarget.com/whatis/definition/domain-driven-design), DDD)_, который помогает сосредоточиться на бизнес-логике и моделировании реальных процессов, разделяя приложение на четкие доменные области. Этот подход способствует созданию масштабируемой архитектуры, улучшает понимание требований и облегчает сопровождение кода.

Бизнес-логика определяет, **что делает приложение**. Она не касается технических аспектов, таких как обработка HTTP-запросов или работа с интерфейсом.

Примеры различий между бизнес-логикой и инфраструктурной логикой:

| Относится к бизнес-логике       | Не относится к бизнес-логике   |
| ------------------------------- | ------------------------------ |
| Расчёт стоимости заказа         | Работа с HTTP-запросами        |
| Определение скидок на товары    | Валидация данных формы         |
| Проверка прав доступа к ресурсу | Отправка уведомлений по e-mail |

## Почему использование сервисов улучшает архитектуру приложения?

Если в приложении не использовать сервисы, логика может сосредоточиться в одном месте, например, в контроллере. Это приводит к следующим проблемам:

- Код становится сложным для чтения и понимания.
- Его сложно тестировать.
- Любые изменения повышают риск ошибок и дублирования.

Рассмотрим пример метода в контроллере, который обрабатывает добавление товара в корзину:

```php
class CartController extends Controller
{
    public function addToCart(Request $request)
    {
        $data = $request->validate([
            'product_id' => 'required|integer',
            'quantity' => 'required|integer',
        ]);

        $product = Product::findOrFail($data['product_id']);
        $cart = Cart::firstOrCreate(['user_id' => auth()->id()]);
        $cartItem = CartItem::firstOrNew([
            'cart_id' => $cart->id,
            'product_id' => $product->id,
        ]);
        $cartItem->quantity += $data['quantity'];
        $cartItem->save();

        return redirect()->route('cart');
    }
}
```

В этом коде смешано несколько задач:

- Валидация данных.
- Поиск или создание корзины.
- Добавление товара в корзину.

Это нарушает **Принцип единственной ответственности (Single Responsibility Principle)** из SOLID, согласно которому класс или метод должны отвечать лишь за одну задачу. Кроме того, если добавить новые правила или изменить логику, потребуется редактировать весь метод, что увеличивает риск ошибок и дублирования кода.

## Разделение логики с помощью сервисов

Одно из решений этой проблемы — **выделение бизнес-логики в отдельные сервисы**. Например, можно создать `CartService`, который будет отвечать за работу с корзиной.

```php
class CartService
{
    /**
     * Добавление товара в корзину.
     *
     * @param array $data Данные о товаре.
     */
    public function addToCart(array $data): void
    {
        $product = Product::findOrFail($data['product_id']);
        $cart = Cart::firstOrCreate(['user_id' => auth()->id()]);
        $cartItem = CartItem::firstOrNew([
            'cart_id' => $cart->id,
            'product_id' => $product->id,
        ]);
        $cartItem->quantity += $data['quantity'];
        $cartItem->save();
    }
}
```

Теперь контроллер становится проще и понятнее:

```php
class CartController extends Controller
{
    protected CartService $cartService;

    public function __construct(CartService $cartService)
    {
        $this->cartService = $cartService;
    }

    public function addToCart(CartRequest $request)
    {
        $this->cartService->addToCart($request->validated());

        return redirect()->route('cart');
    }
}
```

Важно понимать, что сервисы могут быть разных типов. Одни из них отвечают за бизнес-логику, например:

- `CartService` — управление корзиной.
- `OrderService` — обработка заказов.
- `UserService` — управление пользователями.

Другие сервисы решают инфраструктурные задачи:

- `FileService` — работа с файлами.
- `MailService` — отправка электронной почты.
- `MessageGenerator` — генерация сообщений.
- `DataImporter` — импорт данных.
- `FileUploader` — загрузка файлов.

Кроме того, фабрики в Laravel также можно рассматривать как примеры сервисов.