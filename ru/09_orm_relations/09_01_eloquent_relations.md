# Связи между таблицами и моделями в Eloquent

Из курса по базам данных вы уже знаете, что в реляционных базах данных можно создавать связи между таблицами. Это позволяет объединять данные из разных таблиц и использовать их вместе, избегая дублирования данных и таким образом нормализуя структуру базы данных.

Когда мы говорим о связях в контексте Laravel, они устроены схожим образом с тем, как вы привыкли видеть их в реляционных базах данных. Однако сложность добавляет использование ORM (Object-Relational Mapping), что может усложнить понимание этих связей.

Поскольку с ORM появляется дополнительный слой абстракции — **модели**, мы будем рассматривать два типа связей:

- **Между таблицами** в базе данных — это те связи, которые вы изучали на курсе по базам данных.
- **Между моделями** в Laravel — это связи, которые возникают при работе с ORM Eloquent и позволяют работать с данными на уровне объектов, а не только таблиц.

## Создание миграций для таблиц со связями

**Связи между таблицами** в базе данных реализуются с помощью внешних ключей, что вы уже изучали в курсе по базам данных. В Laravel эти связи определяются в миграциях при создании таблиц.

Рассмотрим таблицы `posts` и `categories`, где каждый пост принадлежит одной категории, а категория может содержать множество постов. Это классическое связь **один ко многим**.

Пример создания таблицы `posts` с внешним ключом, ссылающимся на таблицу `categories`:

```php
Schema::create('posts', function (Blueprint $table) {
    $table->id();
    $table->string('title');
    $table->text('content');
    // Колонка для внешнего ключа
    $table->unsignedBigInteger('category_id');
    $table->timestamps();

    // Определение внешнего ключа для category_id
    $table->foreign('category_id')->references('id')->on('categories')
          ->onDelete('cascade')
          ->onUpdate('cascade');
});
```

- `foreign('category_id')` – создает внешний ключ для поля `category_id` в таблице `posts`.
- `references('id')` – ссылается на столбец `id` в таблице `categories`.
- `on('categories')` – указывает таблицу, на которую ссылается внешний ключ.
- `onDelete('cascade')` – удаляет все посты, связанные с категорией, при её удалении (**каскадное удаление**).
- `onUpdate('cascade')` – обновляет связанные посты при изменении категории (**каскадное обновление**).

Этот код эквивалентен следующему SQL-запросу:

```sql
CREATE TABLE posts (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    category_id BIGINT UNSIGNED,
    created_at TIMESTAMP NULL,
    updated_at TIMESTAMP NULL,

    -- Определение внешнего ключа
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE ON UPDATE CASCADE
);
```

### Использование `foreignId`

Начиная с Laravel 7, для упрощения создания внешних ключей был добавлен метод `foreignId`. Теперь не нужно вручную указывать тип поля и отдельно создавать внешний ключ.

Пример использования:

```php
Schema::create('posts', function (Blueprint $table) {
    $table->id();
    $table->string('title');
    $table->text('content');
    $table->foreignId('category_id')->constrained();
    $table->timestamps();
});
```

- `foreignId('category_id')` – создаёт поле `UNSIGNED BIGINT` для внешнего ключа.
- `constrained()` – автоматически определяет таблицу и столбец для связи.

### Таблица "многие ко многим"

Для связи "многие ко многим" требуется промежуточная таблица, содержащая внешние ключи обеих связанных таблиц.

Рассмотрим пример с таблицами `users` и `roles`. Один пользователь может иметь несколько ролей, и одна роль может принадлежать многим пользователям.

Пример создания промежуточной таблицы:

```php
Schema::create('role_user', function (Blueprint $table) {
    $table->id();
    $table->foreignId('user_id')->constrained();
    $table->foreignId('role_id')->constrained();
});
```

Эта миграция создаёт таблицу для связи пользователей с ролями, где каждая запись будет содержать два внешних ключа: один для пользователя и один для роли.

## Отношения в ORM Eloquent

Как уже было упомянуто, при работе с базой данных на уровне объектов в Laravel появляется понятие **связи (отношения) между моделями**.

> [!NOTE] > **Отношения в Laravel** — это одна из ключевых концепций, и, несмотря на её сложность, она является крайне важной для эффективной работы с ORM Eloquent.

Для определения связей между моделями в Eloquent используются **методы-связи**. Эти методы позволяют легко получать связанные данные, например, все посты, относящиеся к категории, или узнать, к какой категории принадлежит конкретный пост.

### Прямые и обратные связи

В Eloquent ORM существует два **типа связей между моделями**: **прямые** и **обратные**.

- **Прямая связь** — когда одна модель **имеет** другую. Например, категория **имеет много** постов.
- **Обратная связь** — когда одна модель **принадлежит** другой. Например, пост **принадлежит** категории.

Эти связи помогают интуитивно работать с объектами, используя понятия "владения" и "принадлежности".

Для определения связей между моделями в Eloquent используются методы `has...` и `belongs...`:

- `has...` — обозначает **прямую связь**, когда одна модель "имеет" другую. Например, категория **имеет много** постов (`hasMany`).
- `belongs...` — обозначает **обратную связь**, когда одна модель "принадлежит" другой. Например, пост **принадлежит** категории (`belongsTo`).

Обратные связи позволяют получать данные из связанных моделей. Например, можно извлечь все посты, принадлежащие категории, или узнать, к какой категории относится конкретный пост.

Логика проста: если одна модель **имеет** другую модель, то эта модель, в свою очередь, **принадлежит** первой.

### Связь "Один к одному" / "Имеет один"

Связь "**один к одному**" описывает ситуацию, когда одна запись из одной таблицы связана **только с одной записью** из другой таблицы.

Рассмотрим пример с таблицами `users` и `profiles`. **У каждого пользователя есть один профиль**, и **каждый профиль принадлежит только одному пользователю**.

> [!NOTE]
> Это удобно, когда нужно хранить дополнительные данные (имя, фамилию, дату рождения, и т.д.) о пользователе в отдельной таблице, чтобы структура данных была логичной и легко управляемой.

В базе данных таблицы будут иметь следующую структуру:

- `users` — содержит данные о пользователях.
  - `id`
  - `name`
  - `email`
  - `created_at`
  - `updated_at`

- `profiles` — содержит дополнительные данные о пользователях.
  - `id`
  - `user_id` (внешний ключ)
  - `phone`
  - `address`
  - `created_at`
  - `updated_at`

#### Связь моделей: `hasOne`

Метод `hasOne` используется для определения связи "один к одному", где _одна_ модель **имеет** _одну_ другую модель.

Рассмотрим пример с моделями `User` и `Profile`.

В нашем случае это значит, что _пользователь_ **имеет один** _профиль_.

Чтобы создать такую связь между моделями, добавляем в модель `User` метод `profile()` (_название метода может быть любое_), который вернёт связь `hasOne` с моделью `Profile`.

```php
<?php

// app/Models/User.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model {
    // ...

    public function profile() {
        return $this->hasOne(Profile::class);
    }
}
```

Этот метод говорит Laravel, что каждый пользователь связан с одним профилем. Теперь, когда мы вызовем `$user->profile`, Eloquent автоматически найдёт профиль, связанный с этим пользователем.

#### Связь моделей: `belongsTo`

Метод `belongsTo` используется для создания обратной связи "один к одному", где _одна модель принадлежит другой_. Это значит, что модель `Profile` "принадлежит" модели `User`.

Для реализации добавляем метод `user()` в модель `Profile`, указывая, что каждый профиль связан с определённым пользователем.

```php
<?php

// app/Models/Profile.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Profile extends Model {

    public function user() {
        return $this->belongsTo(User::class);
    }
}
```

Метод `user()` сообщает Laravel, что профиль связан с определённым пользователем. Теперь, когда мы вызовем `$profile->user`, Eloquent автоматически найдёт пользователя, которому принадлежит этот профиль.

Подведём итог, что мы получили:

1. **Метод `hasOne`** в `User` показывает, что у пользователя есть один профиль.
2. **Метод `belongsTo`** в `Profile` показывает, что профиль принадлежит одному пользователю.

Эти связи позволяют легко получить профиль для пользователя (`$user->profile`) или найти пользователя, к которому относится конкретный профиль (`$profile->user`).

> [!TIP]
> Таким образом мы можем легко создавать и использовать связи между моделями в Laravel, что делает работу с данными более удобной и интуитивной.

### Связь "Один ко многим" / "Имеет много"

Связь "**один ко многим**" описывает ситуацию, когда одна запись из одной таблицы может быть связана с несколькими записями в другой таблице.

Рассмотрим пример с таблицами `categories` и `posts`. **Каждая категория может иметь много постов**, и **каждый пост принадлежит только одной категории**.

В базе данных таблицы будут иметь следующую структуру:

- `categories` — содержит данные о категориях.

  - `id`
  - `name`
  - `created_at`
  - `updated_at`

- `posts` — содержит данные о постах.
  - `id`
  - `category_id` (внешний ключ)
  - `title`
  - `content`
  - `created_at`
  - `updated_at`

#### Связь моделей: `hasMany`

Метод `hasMany` используется для определения связи "один ко многим", где _одна_ модель **имеет много** других моделей.

Рассмотрим пример с моделями `Category` и `Post`.

В нашем случае это значит, что _категория_ **имеет много** _постов_.

Чтобы создать такую связь между моделями, добавляем в модель `Category` метод `posts()` (_название метода может быть любое_), который вернёт связь `hasMany` с моделью `Post`.

```php
<?php

// app/Models/Category.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Category extends Model {
    // ...

    public function posts() {
        return $this->hasMany(Post::class);
    }
}
```

Этот метод сообщает Laravel, что каждая категория может иметь несколько постов. Теперь, когда мы вызовем `$category->posts`, Eloquent автоматически найдёт все посты, связанные с этой категорией.

#### Связь моделей: `belongsTo`

Метод `belongsTo` используется для создания обратной связи "один ко многим", где _одна модель принадлежит другой_. Это значит, что модель `Post` "принадлежит" модели `Category`. Подробнее данный тип связи был рассмотрен в предыдущей подглаве.

```php
<?php

// app/Models/Post.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Post extends Model {

    public function category() {
        return $this->belongsTo(Category::class);
    }
}
```

Метод `category()` сообщает Laravel, что пост принадлежит конкретной категории. Теперь, когда мы вызовем `$post->category`, Eloquent автоматически найдёт категорию, к которой относится этот пост.

Подведём итог, что мы получили:

1. **Метод `hasMany`** в `Category` показывает, что у категории может быть много постов.
2. **Метод `belongsTo`** в `Post` показывает, что каждый пост принадлежит одной категории.

Эти связи позволяют легко получить все посты для категории (`$category->posts`) или найти категорию, к которой относится конкретный пост (`$post->category`).

### Связь "Многие ко многим"

Связь "**многие ко многим**" описывает ситуацию, когда одна запись из одной таблицы может быть связана с несколькими записями в другой таблице, и наоборот.

Для таких связей требуется промежуточная таблица, которая содержит внешние ключи обеих связанных таблиц.

Рассмотрим пример с таблицами `users` и `roles`. **Один пользователь может иметь несколько ролей**, и **одна роль может принадлежать многим пользователям**.

В базе данных таблицы будут иметь следующую структуру:

- `users` — содержит данные о пользователях.ы
  - `id`
  - `name`
  - `email`
  - `created_at`
  - `updated_at`

- `roles` — содержит данные о ролях.
  - `id`
  - `name`
  - `created_at`
  - `updated_at`

- `role_user` — промежуточная таблица для связи пользователей с ролями.
  - `id`
  - `user_id` (внешний ключ)
  - `role_id` (внешний ключ)

#### Связь моделей: `belongsToMany`

Метод `belongsToMany` используется для определения связи "**многие ко многим**" между моделями.

Рассмотрим пример с моделями `User` и `Role`.

В нашем случае это значит, что _пользователь_ **имеет много** _ролей_, и _роль_ **принадлежит многим** _пользователям_.

Чтобы создать такую связь между моделями, добавляем в модель `User` метод `roles()` (_название метода может быть любое_), который вернёт связь `belongsToMany` с моделью `Role`.

```php
<?php

// app/Models/User.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model {
    // ...

    public function roles() {
        return $this->belongsToMany(Role::class);
    }
}
```

В модели также необходимо указать связь в обратную сторону, добавив метод `users()` в модель `Role`. В случае со связью многие ко многим обратная связь также является `belongsToMany`.

```php
<?php

// app/Models/Role.php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Role extends Model {
    // ...

    public function users() {
        return $this->belongsToMany(User::class);
    }
}
```

Теперь мы можем легко получить все роли для пользователя (`$user->roles`) или найти всех пользователей, имеющих определённую роль (`$role->users`).

### Получение связанных данных

После того как мы определили связи между моделями в Eloquent, мы можем легко получать связанные данные.

#### Получение связанных данных "один к одному"

Для начала рассмотрим связь "**один к одному**" на примере моделей `User` и `Profile`. В этой связи каждому пользователю соответствует один профиль, и наоборот, каждому профилю соответствует один пользователь.

Чтобы получить профиль конкретного пользователя, мы можем использовать метод-связь `profile`, как свойство:

```php
// Получение профиля для пользователя с id 1
$profile = User::find(1)->profile;
```

Здесь мы используем `profile` как **свойство** — Eloquent автоматически выполнит запрос на получение связанного профиля без необходимости вызывать его как метод.

Аналогично, чтобы получить пользователя для профиля:

```php
// Получение пользователя для профиля с id 1
$user = Profile::find(1)->user;
```

#### Получение связанных данных "один ко многим"

В связи "один ко многим" одна запись в одной модели связана с несколькими записями в другой модели. Например, модель `Category` может иметь множество записей в модели `Post`, и каждый пост принадлежит одной категории.

Чтобы получить все посты для конкретной категории, можно использовать `posts` как **свойство**:

```php
// Получение всех постов для категории с id 1
$category = Category::find(1);
$posts = $category->posts;
```

Если нам нужно вывести заголовки всех постов категории:

```php
foreach ($posts as $post) {
    echo $post->title;
}
```

Для получения категории, к которой относится конкретный пост:

```php
// Получение категории для поста с id 1
$post = Post::find(1);
$category = $post->category;
```

#### Получение связанных данных "многие ко многим"

Связь "многие ко многим" означает, что одна запись в одной модели может быть связана с несколькими записями в другой модели, и наоборот. Примером может служить связь между моделями `User` и `Role`, где пользователь может иметь несколько ролей, а роль может принадлежать нескольким пользователям.

Можно получить все роли для конкретного пользователя, используя `roles` как **свойство**:

```php
// Получение всех ролей для пользователя с id 1
$user = User::find(1);
$roles = $user->roles;
```

Чтобы вывести названия всех ролей пользователя:

```php
foreach ($roles as $role) {
    echo $role->name;
}
```

Для получения всех пользователей, которые имеют конкретную роль:

```php
// Получение всех пользователей для роли с id 1
$role = Role::find(1);
$users = $role->users;
```

#### Использование pivot-таблицы

Для связи "многие ко многим" Eloquent автоматически создает **pivot-таблицу**, которая хранит связи между моделями. Например, для `User` и `Role` pivot-таблицей может быть `role_user`, содержащая только `user_id` и `role_id`. Иногда в pivot-таблице могут быть дополнительные поля, такие как `created_at`.

Чтобы получить доступ к данным pivot-таблицы, используйте метод `pivot`:

```php
// Получение всех ролей для пользователя и данных из pivot-таблицы
$user = User::find(1);
foreach ($user->roles as $role) {
    echo $role->pivot->created_at; // доступ к данным pivot-таблицы
}
```

Чтобы включить доступ к данным pivot-таблицы, добавьте `withPivot` в определение связи:

```php
// В модели User
public function roles()
{
    return $this->belongsToMany(Role::class)->withPivot('created_at');
}
```

Теперь вы можете получить поле `created_at` из pivot-таблицы, когда работаете с ролями пользователя.

#### Построитель запросов для связей

Eloquent позволяет использовать **построитель запросов** для фильтрации, сортировки и других операций на связанных данных. Чтобы это сделать, вызывайте метод-связь как **метод** (с `()`), добавляя нужные условия:

```php
$publishedPosts = Category::find(1)->posts()
    ->where('is_published', true)
    ->orderBy('created_at', 'desc')
    ->get();
```

В данном примере `posts()` используется как метод, позволяя добавлять условия и сортировку к результатам, что невозможно при обращении к связи как к свойству.

#### Использование связи как метод или как свойство

Когда мы используем связь как **свойство** (`$user->profile`), Eloquent делает запрос сразу при обращении. Это удобно для простого получения данных, но если нужно добавить условия, сортировку или отфильтровать данные, необходимо использовать связь как **метод**.

Например:

```php
// Используем связь как метод для добавления условий
$publishedPosts = Category::find(1)->posts()
    ->where('is_published', true)
    ->orderBy('created_at', 'desc')
    ->get();
```

Здесь `posts()` используется как **метод**, что позволяет гибко настраивать запрос и получить только нужные данные.

### Запрос наличия отношений

Когда мы работаем с моделями, иногда необходимо выбрать только те записи, которые имеют связанные данные.

Например, мы можем захотеть получить только те категории, у которых есть хотя бы один пост. Eloquent предоставляет удобный метод для этого — `has`.

```php
$categoriesWithPosts = Category::has('posts')->get();
```

Этот запрос вернет только те категории, у которых есть связанные посты. Если мы хотим добавить условие, например, выбрать категории, у которых больше одного поста, мы можем сделать это так:

```php
$categoriesWithMultiplePosts = Category::has('posts', '>', 1)->get();
```

Таким образом, мы можем легко фильтровать записи, ориентируясь на наличие связанных данных.

### Eager Loading (жадная загрузка)

Жадная загрузка или **Eager Loading** помогает решить проблему, называемую "проблемой N+1 запросов". Эта проблема возникает, когда мы сначала запрашиваем основные записи (например, категории) и затем для каждой из них выполняем отдельный запрос для получения связанных данных (например, постов). 

#### Проблема N+1 запросов

Представим, что мы запрашиваем список категорий, и для каждой категории нам нужно получить все связанные посты. Без `Eager Loading` запросы выглядят примерно так:

```php
$categories = Category::all(); // Первый запрос
foreach ($categories as $category) {
    $posts = $category->posts; // Дополнительный запрос для каждой категории
}
```

Здесь `Category::all()` выполняет один запрос, а затем для каждой категории Eloquent делает отдельный запрос к базе данных для получения постов. Таким образом, если у нас 10 категорий, это приведет к 11 запросам (1 запрос для категорий + 10 запросов для постов каждой категории). Если количество категорий велико, количество запросов быстро увеличивается, замедляя работу приложения.

Чтобы избежать этого, можно использовать `Eager Loading`, заранее загрузив посты для всех категорий:

```php
$categories = Category::with('posts')->get();
```

Теперь Eloquent выполнит только два запроса: один для категорий и один для всех постов, связанных с этими категориями. Это эффективно решает проблему N+1 запросов и повышает производительность.

#### Когда связные данные могут быть не нужны

Иногда, нам может быть достаточно получить только основные записи, без связанных данных. Например, если мы просто хотим вывести список категорий для фильтрации или выбора, нам нет необходимости загружать посты для каждой категории, так как нам нужна только основная информация.

```php
$categories = Category::all();
```

В этом случае `Eager Loading` не используется, так как нам не нужны данные из других таблиц. Мы экономим ресурсы и избегаем лишних запросов, загружая только те данные, которые действительно необходимы для конкретной задачи.

### Вставка и обновление связанных данных

Eloquent также позволяет легко вставлять и обновлять связанные данные. Например, если у нас есть категория, и мы хотим добавить к ней новый пост, мы можем сделать это так:

```php
$category = Category::find(1);
$post = new Post([
    'title' => 'Новый пост',
    'content' => 'Содержание поста...'
]);

$category->posts()->save($post);
```

Мы создали новый пост и связали его с категорией. Таким образом, Eloquent автоматически установит `category_id` для нового поста. Обновление связанных данных также просто. Например, чтобы изменить заголовок поста, можно сделать так:

```php
$post = Post::find(101);
$post->title = 'Обновленный заголовок';
$post->save();
```

Так мы можем легко управлять данными, связанными друг с другом.

### Загрузка связанных данных

При использовании ORM, как Eloquent, мы получаем возможность работать с моделями и легко загружать связанные данные. Это позволяет получать не только сами записи, но и данные из связанных таблиц. Например, загружая категории с постами, мы сразу получаем все посты, относящиеся к каждой категории, что упрощает и ускоряет работу с данными.

## Заключение

Связи между таблицами и моделями в Eloquent — это мощный инструмент для работы с данными, позволяющий избежать излишних запросов и упростить доступ к связанным данным. Понимание того, как работают связи между таблицами и моделями, помогает эффективнее использовать Laravel и делать код более структурированным и понятным. 

В этом разделе мы изучили, как создавать связи на уровне базы данных через миграции и как определять связи на уровне моделей в Laravel. Мы также познакомились с такими важными аспектами, как проблема N+1 запросов, решение которой предлагается через жадную загрузку (Eager Loading), а также научились создавать и обновлять связанные данные.

ORM Eloquent автоматически загружает связанные данные при вызове методов-связей, предоставляя разработчику простой и удобный способ работы с данными. Благодаря этому можно быстро получать нужную информацию из связанных таблиц, избегая ручного написания сложных SQL-запросов.