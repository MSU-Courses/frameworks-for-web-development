# Разделение на компоненты

Как мы говорили ранее, одним из основных премуществ шаблонизаторов является возможность разделения кода и его переиспользование.

В этом разделе мы рассмотрим, как разделить шаблон на компоненты и различные способы их использования.

## Что такое компонент?

**Компонент** — это часть шаблона, которая может быть использована повторно в различных местах вашего проекта [^3].

Компоненты могут быть как простыми, так и сложными.

- **Примеры простых компонентов**: кнопка, иконка, заголовок.
- **Примеры сложных компонентов**: карточка товара, форма обратной связи, меню.

> [!NOTE]  
> Компонент может содержать другие компоненты, что позволяет создавать сложные интерфейсы из простых частей. Например, карточка товара может включать кнопку "Добавить в корзину".

Когда на странице появляется много HTML и логики, разделение на компоненты помогает упростить код и значительно улучшить его читаемость.

## Когда разделять шаблон на компоненты?

Одним из основных _философских_ вопросов, который возникает при разработке шаблонов, является вопрос о том, _когда следует разделять шаблон на компоненты_, то есть на более мелкие части.

Нет единого ответа на этот вопрос, но есть некоторые рекомендации, которые помогут вам принять решение:

- **Переиспользуемость**: если часть шаблона может использоваться в разных местах проекта, это явный признак того, что её стоит выделить в компонент.
- **Сложность и объем**: если часть шаблона содержит много HTML и сложной логики, разделение на компоненты упростит код и повысит его читаемость.

Давайте рассмотрим пример разделения шаблона на компоненты.

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Список постов</title>
  </head>
  <body>
    @foreach ($posts as $post)
    <div class="post">
      <h2>{{ $post.title }}</h2>
      <p>{{ $post.content }}</p>
      <span>{{ $post.author }}</span>
    </div>
    @endforeach
  </body>
</html>
```

В приведенном примере каждый пост содержит заголовок, содержимое и автора. Эти элементы могут быть выделены в компонент для упрощения кода и улучшения его читаемости.

```html
<!-- Компонент "Пост" -->
<div class="post">
  <h2>{{ $post.title }}</h2>
  <p>{{ $post.content }}</p>
  <span>{{ $post.author }}</span>
</div>
```

Как вы думаете, почему в данном случае разделение на компоненты улучшает код?

## Разделение на компоненты в Laravel [^1]

В Laravel Blade существует множество способов разделения шаблона на компоненты: более простые и более сложные.

### Наследование шаблонов

Одним из наиболее мощных инструментов шаблонизаторов, таких как Laravel Blade, является **наследование шаблонов**.

Суть этого механизма проста: вы создаете базовый шаблон (`layout`), который включает общие элементы для всех страниц вашего сайта, такие как структура, меню навигации, подвал и т.д. Затем создаете дочерние шаблоны, которые наследуют этот базовый шаблон и добавляют свои уникальные элементы.

Вы можете создать несколько layout'ов для разных частей сайта, например, один для пользовательской части, а другой — для административной панели.

Обычно layout'ы хранятся в директории `resources/views/layouts`.

#### Пример базового и дочернего шаблона

Рассмотрим создание базового шаблона `app.blade.php` и дочернего шаблона `home.blade.php`.

```blade
<!-- resources/views/layouts/app.blade.php -->
<!-- Базовый layout приложения с общими элементами -->
<!DOCTYPE html>
<html>
  <head>
    <title>@yield('title')</title>
    <!-- Подключение стилей и скриптов -->
    <link rel="stylesheet" href="styles.css">
    <script src="script.js"></script>
  </head>
  <body>
   <header>...</header>
    <main>
      <h1>@yield('title')</h1>
      @yield('content')
    </main>
    <footer>...</footer>
  </body>
</html>
```

Директива `@yield` указывает места, в которые будет вставлено содержимое дочерних шаблонов. Эти области могут быть переопределены в дочерних шаблонах.

```blade
<!-- resources/views/home.blade.php -->
<!-- Дочерний шаблон, наследующий layout -->
@extends('layouts.app')

@section('title', 'Главная страница')

@section('content')
  <p>Добро пожаловать на главную страницу!</p>
  <p>Ваш ник: {{ $username }}</p>
@endsection
```

В дочернем шаблоне `home.blade.php` используется директива `@extends` для наследования базового шаблона `app.blade.php`. Директивы `@section` позволяют определить содержимое, которое будет вставлено в соответствующие области базового шаблона.

Директива `@section` может быть использована как для коротких, так и для длинных блоков кода.

#### Как это работает?

Благодаря наследованию шаблона `app.blade.php`, содержимое дочернего шаблона `home.blade.php` будет автоматически вставлено в указанные области базового шаблона:

```blade
<!DOCTYPE html>
<html>
  <head>
    <title>Главная страница</title>
    <link rel="stylesheet" href="styles.css">
    <script src="script.js"></script>
  </head>
  <body>
   <header>...</header>
    <main>
      <h1>Главная страница</h1>
      <p>Добро пожаловать на главную страницу!</p>
      <p>Ваш ник: {{ $username }}</p>
    </main>
    <footer>...</footer>
  </body>
</html>
```

Таким образом, **вам не придется дублировать один и тот же код на каждой странице**, что значительно упрощает поддержку и разработку.

Например, вы можете подключить JS или CSS файлы в базовом шаблоне, и они будут автоматически доступны на всех страницах, которые наследуют этот шаблон (_как показано выше_).

### Директива `@include`

Одним из самых простых способов разделения шаблона на компоненты является использование директивы `@include`.

> [!NOTE]  
> Использование директивы `@include` — это простой и эффективный способ разделения шаблона на компоненты.

Директива `@include` позволяет вставить содержимое одного шаблона в другой, делая код более модульным и удобным для повторного использования.

Общий синтаксис директивы `@include`:

```blade
@include('component-name', ['data1' => $data1, 'data2' => $data2, ...])
```

Рассмотрим пример использования директивы `@include` для вставки компонента "Пост" в шаблон "Список постов":

```blade
<!-- resources/views/posts.blade.php -->
<!DOCTYPE html>
<html>
<head>
    <title>Список постов</title>
</head>
<body>
    @foreach ($posts as $post)
        @include('components.post', ['post' => $post])
    @endforeach
</body>
</html>
```

```blade
<!-- resources/views/components/post.blade.php -->
<div class="post">
    <h2>{{ $post.title }}</h2>
    <p>{{ $post.content }}</p>
    <span>{{ $post.author }}</span>
</div>
```

Таким образом, директива `@include` вставляет содержимое указанного компонента на месте своего вызова, делая код более структурированным и переиспользуемым.

С помощью директивы `@includeWhen` можно включить компонент в шаблон только при выполнении определенного условия:

```blade
@includeWhen($condition, 'component-name', ['data1' => $data1, 'data2' => $data2, ...])
```

Если условие `$condition` истинно, компонент будет добавлен в шаблон.

### Компоненты Blade

Как упоминалось ранее, директива `@include` — это простой способ вставить содержимое одного шаблона в другой. Однако в современных приложениях этот метод используется всё реже.

В Laravel Blade есть более мощный и гибкий инструмент для работы с шаблонами — **компоненты Blade**.

> [!NOTE]  
> При создании этой функциональности разработчики вдохновлялись компонентами Vue.

Существует два основных метода написания компонентов Blade:

- **Классовые компоненты**;
- **Анонимные компоненты**.

Рассмотрим каждый из них.

### Классовые компоненты

Классовые компоненты в Laravel можно создать двумя способами: вручную или с помощью команды Artisan. Рассмотрим создание компонента с использованием команды Artisan.

#### Создание классового компонента

Чтобы создать классовый компонент, выполните команду Artisan `make:component`:

```bash
php artisan make:component Post
```

Эта команда создаст классовый компонент `Post` в директории `app/View/Components` и соответствующий шаблон в `resources/views/components`.

#### Использование классового компонента

После создания компонента, его можно использовать в шаблонах, применяя директиву `x-component`, где имя компонента записывается в формате _kebab-case_:

```blade
<x-post />
```

```blade
<!-- resources/views/components/post.blade.php -->
<div class="post">
   <!-- Content -->
</div>
```

Если ваш компонент находится во вложенных поддиректориях, укажите путь к нему через точку:

```blade
// resources/views/components/blog/post.blade.php
<x-blog.post />
```

#### Передача данных в компонент

При создании компонента генерируется класс, который может принимать данные через свойства, передаваемые в конструктор. Важно отметить, что если в конструкторе используются свойства в формате _camelCase_, то в шаблоне они передаются через атрибуты в формате _kebab-case_.

Пример:

```php
// app/View/Components/Post.php

class Post extends Component
{
   public string $title;
   public string $description;
   public string $authorName;

    public function __construct(string $title, string $description, string $authorName)
    {
        $this->title = $title;
        $this->description = $description;
        $this->authorName = $authorName;
    }

    public function render()
    {
        return view('components.post');
    }
}
```

В данном примере компонент принимает три свойства: `title`, `description` и `authorName`, которые передаются через конструктор.

Для передачи данных в компонент используйте атрибуты, где формат _camelCase_ из конструктора преобразуется в _kebab-case_ в шаблоне:

```blade
<x-post title="Post title" description="Post description" author-name="Nick" />
```

Если значения хранятся в переменных, можно использовать синтаксис Blade:

```blade
<x-post
   :title="$post->title"
   :description="$post->description"
   :author-name="$post->author"
 />
```

Сам компонент будет выглядеть следующим образом:

```blade
<!-- resources/views/components/post.blade.php -->
<div class="post">
    <h2>{{ $title }}</h2>
    <p>{{ $description }}</p>
    <span>{{ $authorName }}</span>
</div>
```

#### Атрибуты компонента

Часто бывает необходимо задать компоненту стандартные атрибуты, такие как класс или id. Для этого можно использовать переменную `$attributes` в шаблоне компонента:

```blade
<!-- resources/views/components/post.blade.php -->
<div {{ $attributes }}>
      <!-- Content -->
</div>
```

Теперь можно передавать атрибуты в компонент следующим образом:

```blade
// В шаблоне вместо $attributes будут подставлены class="post" и id="post-1"

<x-post class="post" id="post-1" />
```

Таким образом, любые дополнительные атрибуты, переданные компоненту, будут автоматически добавлены к его HTML-разметке.

### Анонимные компоненты [^2]

**Анонимные компоненты** — это еще один способ создания компонентов в Laravel Blade. Они позволяют создавать компоненты прямо в шаблоне, без необходимости создавать отдельный класс.

Этот метод удобен, когда компонент имеет простую логику и не требует сложной обработки данных. Анонимные компоненты создаются только с помощью шаблонов и находятся в директории `resources/views/components`.

При этом вам достаточно создать файл, а Blade автоматически распознает его как компонент.

Либо можно использовать `artisan` для создания анонимного компонента с помощью флага `--view`:

```bash
php artisan make:component post --view
```

#### Использование анонимного компонента

Анонимные компоненты создаются в шаблоне с помощью директивы `x-component`:

```blade
<!-- resources/views/components/post.blade.php -->
<div>
   <h2>{{ $title }}</h2>
   <p>{{ $description }}</p>
   <span>{{ $authorName }}</span>
</div>
```

```blade
<!-- resources/views/posts.blade.php -->
<x-post title="Post title" description="Post description" author-name="Nick" />
```

#### Пропсы анонимного компонента

Иногда необходимо задать стандартные значения для свойств (параметров) компонента или сделать так, чтобы IDE могла подсказывать доступные параметры для передачи в компонент.

> [!IMPORTANT]
> Четкое определение используемых параметров также улучшает читаемость кода.

Для этого в анонимных компонентах используются **пропсы** (от англ. _props_, свойства).

**Пропсы** — это данные, передаваемые в компонент. В анонимных компонентах они передаются через атрибуты.

Пример использования пропсов с указанием значений по умолчанию:

```blade
@props([
   'title' => 'Default title',
   'description' => 'Default description',
   'authorName' => 'Default author'
])

<div>
   <h2>{{ $title }}</h2>
   <p>{{ $description }}</p>
   <span>{{ $authorName }}</span>
</div>
```

```blade
<x-post title="Title" />
// Выведен:
// <h2>Title</h2>
// <p>Default description</p>
// <span>Default author</span>
```

Если какой-либо из пропсов не передан при вызове компонента, будет использовано его стандартное значение. Это делает компонент более гибким и упрощает его использование.

Определение значений по умолчанию позволяет не передавать все пропсы при вызове компонента, если в этом нет необходимости.

Также вы можете определить пропсы без указания значений по умолчанию:

```blade
@props(['title', 'description', 'authorName'])

// ...
```

В таком случае эти пропсы будут обязательны для передачи при вызове компонента.

```blade
// Ошибка: не переданы обязательные пропсы
<x-post title="Title" />
```

### Соединение атрибутов

В компонентах часто требуется добавлять атрибуты, независимо от того, были ли они переданы при вызове компонента.

Для этого можно использовать метод `merge`, который объединяет переданные атрибуты с дополнительными:

```blade
<!-- resources/views/components/post.blade.php -->
<div {{ $attributes->merge(['class' => 'bg-gray-100']) }}>
   <!-- Content -->
</div>
```

Теперь при вызове компонента можно передать дополнительные атрибуты:

```blade
<x-post class="text-center" />

// Результат:
// <div class="bg-gray-100 text-center">
```

Таким образом, класс `bg-gray-100` будет всегда добавлен, а переданные классы, такие как `text-center`, объединяются с ним.

### Слоты компонентов

**Слоты** — это мощная и удобная функция компонентов, позволяющая передавать не просто данные, а целые фрагменты содержимого, которые можно вставить в нужное место внутри компонента.

#### Как работают слоты

Слотом называется место в компоненте, куда будет вставлено переданное содержимое. Это позволяет сделать компонент более гибким и универсальным. Для использования слота в шаблоне компонента применяется переменная `$slot`.

Пример:

```blade
<!-- resources/views/components/alert.blade.php -->
<div class="alert">
   <h2>{{ $title }}</h2>
   <div>{{ $slot }}</div>
</div>
```

В этом шаблоне содержимое, переданное в компонент, будет вставлено на место переменной `$slot`.

#### Пример использования слотов

При вызове компонента можно передать как данные (например, заголовок), так и содержимое, которое попадет в слот:

```blade
<x-alert title="Предупреждение">
   // Это содержимое будет вставлено вместо переменной $slot,
   // то есть все, что находится внутри тега x-component (x-alert)
   <strong>Это сообщение о предупреждении!</strong>
   <p>Дополнительный текст</p>
</x-alert>
```

Результат:

```html
<div class="alert">
  <h2>Предупреждение</h2>
  <div>
    <!-- Это содержимое будет вставлено вместо переменной $slot -->
    <strong>Это сообщение о предупреждении!</strong>
    <p>Дополнительный текст</p>
  </div>
</div>
```

Таким образом, слот позволяет легко вставлять разное содержимое в компонент, делая его универсальным.

Это особенно полезно, когда нужно передавать как статические данные, так и динамическое содержимое.

#### Именованные слоты

**Именованные слоты** позволяют передавать в компонент несколько разных фрагментов содержимого. Это полезно, когда компонент должен иметь несколько областей для вставки данных.

Рассмотрим пример компонента с именованными слотами:

```blade
<!-- resources/views/components/form.blade.php -->
<form>
   {{ $slot }} <!-- Основное содержимое -->
</form>

<div id="buttons">
   {{ $buttons }} <!-- Дополнительное содержимое (например, кнопки) -->
</div>
```

В этом примере:

- `$slot` — это основной слот, куда будет вставлено основное содержимое.
- `$buttons` — именованный слот для дополнительного содержимого, такого как кнопки.

#### Использование именованных слотов

Чтобы передать содержимое в именованные слоты, используйте директиву `x-slot` с указанием имени слота.

Пример:

```blade
<x-form>
   <x-slot:buttons>
      <button>Отправить</button>
   </x-slot:buttons>

   <input type="text" name="name" />
</x-form>
```

В этом примере:

- Содержимое внутри директивы `<x-slot:buttons>` будет вставлено в слот `$buttons`.
- Всё остальное содержимое, переданное компоненту, будет вставлено в основной слот `$slot`.

## `@include` vs. компоненты Blade

Как мы видим, в Laravel Blade есть несколько способов разделения шаблона на компоненты: директива `@include`, классовые и анонимные компоненты.

Используйте директиву `@include`, если:
1. Если нужно подключить простой HTML-фрагмент (например, футер, хедер или меню), который не содержит сложной логики
2. Когда часть шаблона не требует переиспользуемого кода и может оставаться статичной или минимально динамичной.

В остальных случаях рекомендуется использовать компоненты Blade, так как они обладают рядом преимуществ:

## Пример разделения шаблона на компоненты

Рассмотрим пример, как разделить шаблон на компоненты в Laravel. Этот подход помогает организовать код, делает его более читабельным и облегчает поддержку.

### `layouts/app.blade.php` — базовый шаблон:

```blade
<!DOCTYPE html>
<html>
<head>
    <title>@yield('title')</title>
</head>
<body>
    <header>
        <!-- Header -->
    </header>

    <main>
        @yield('content')
    </main>

    <footer>
        <!-- Footer -->
    </footer>
</body>
</html>
```

### `auth.blade.php` — шаблон страницы аутентификации:

```blade
@extends('layouts.app')

@section('title', 'Авторизация')

@section('content')
    <x-auth.login-form />
@endsection
```

### `components/forms/text-input.blade.php` — компонент текстового поля:

```blade
@props([
   'name',
   'type' => 'text',
   'isError' => false,
])

<input
   type="{{ $type }}"
   name="{{ $name }}"
   placeholder="{{ $placeholder }}"
   {{ $attributes->class(['error' => $isError]) }}
/>
```

### `components/forms/form.blade.php` — компонент формы:

```blade
<form {{ $attributes }}>
   {{ $slot }}
</form>

<div id="buttons">
   {{ $extraButtons }}
</div>

<ul>
   <li><a href="{{ route('user.agreement') }}">Пользовательское соглашение</a></li>
   <li><a href="{{ route('user.policy') }}">Политика конфиденциальности</a></li>
</ul>
```

### `auth/login-form.blade.php` — компонент формы авторизации:

```blade
<x-forms.form {{-- остальные атрибуты формы --}} >
   <x-forms.text-input name="login" placeholder="Логин" />

   @error('login')
      <p class="error">{{ $message }}</p>
   @enderror

   <x-forms.text-input name="password" placeholder="Пароль" type="password" />

   @error('password')
      <p class="error">{{ $message }}</p>
   @enderror

   <button>Войти</button>

   <x-slot:extraButtons>
      <a href="/forgot-password">Забыли пароль?</a>
   </x-slot>
</x-forms.form>
```

Этот пример демонстрирует, как можно разделить шаблон на компоненты, что значительно упрощает его поддержку и улучшает читаемость кода. Вы можете гибко переиспользовать компоненты и легко обновлять отдельные части приложения, не затрагивая весь шаблон.

[^1]: Components, laravel.com [online]. URL: https://laravel.com/docs/10.x/blade#components
[^2]: Anonymous Components, laravel.com [online]. URL: https://laravel.com/docs/10.x/blade#anonymous-components
[^3]: 5 Ways Component-Based Design Empowers Web Development, it-consultis.com [online]. URL: https://it-consultis.com/blog/component-based-design/
